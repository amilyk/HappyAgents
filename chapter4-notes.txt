ReAct：思考+行动，边想边做
Plan-and-Solve:先想好方案，一步一步做
Reflection：反思能力，自我批判优化结果

1.ReAct
推理+行动

Thought：制定策略
Action：根据任务调用工具
Observation：工具返回的结果
需要使用外部工具的智能体
* 需要外部知识的任务：如查询实时信息（天气、新闻、股价）、搜索专业领域的知识等。
* 需要精确计算的任务：将数学问题交给计算器工具，避免LLM的计算错误。
* 需要与API交互的任务：如操作数据库、调用某个服务的API来完成特定功能。

ReAct优势：
解释性强（Thought链） 
动态纠错能力（上一步的Action和Observation作为历史，动态调整后续的Thought和Action）
工具协同能力（LLM推理叠加上外部工具解决具体问题，解决LLM知识时效性、计算准确性的缺失）

ReAct缺点：
LLM能力依赖（LLM能力差，影响Thought产生正确与否）
执行效率（一个任务需要调用多次LLM，耗时+计算成本高）
提示词模板依赖（提示词差异影响LLM行为）
可能局部最优（依赖于上一步的Observation做决策）

ReAct智能体查错和调优：
1.检查提示词模板
2.提示词模板中增加few shot，比如几个正确的Thought Action Observation案例
3.尝试能力更强的LLM模型或LLM参数（Temperature、top k、top p）
4.分析LLM输出，是否能解析出正确Action
5.检查（Action所对应的）工具的输入输出参数（tool input、Observation）

2.Plan and Solve
分步骤的计划+逐一执行计划（需要拆解任务，目标是一开始分步骤定好的，不会偏移）

规划阶段 (Planning Phase)：将问题分解，并制定出一个清晰、分步骤的行动计划
执行阶段 (Solving Phase)：严格按照计划中的步骤，逐一执行

结构性强，可以被分解的复杂任务：
* 多步数学应用题：需要先列出计算步骤，再逐一求解。
* 需要整合多个信息源的报告撰写：需要先规划好报告结构（引言、数据来源A、数据来源B、总结），再逐一填充内容。
* 代码生成任务：需要先构思好函数、类和模块的结构，再逐一实现。

3.Reflection
任务完成以后，检查审视，然后自我校正

1.Execution执行：
（ReAct、Plan and Solve）解决任务，得到初稿
2.Reflection反思：评审（特殊提示词LLM）
事实错误（与已知违背、常识违背）
逻辑漏洞（推理过程错误）
效率问题（是否有更快更好解决方案）
遗漏信息（问题约束是否考虑全）
3.Refinement优化
（初稿+反馈） -> LLM，修正初稿

Reflection优势
1.纠错机制
2.持续优化，提升答案正确率
3.短期记忆，执行-反思-优化，初稿迭代到最终版本（还可以是多模态的）

适合最终结果的质量、准确性和可靠性有极高要求，且对任务完成的实时性要求相对宽松的场景。
（对结果要求高，但时效性低的任务）
例如:
* 生成关键的业务代码或技术报告。
* 在科学研究中进行复杂的逻辑推演。
* 需要深度分析和规划的决策支持系统。

Reflection优势
解决方案质量提升（性能、功能、逻辑都有提升）
鲁棒性与可靠性增强（解决逻辑漏洞、边界错误等）


3种智能体总结
1. ReAct:通过“思考-行动-观察”的动态循环，利用外部工具比如搜索引擎（或者其他API），解决知识库实时性问题。其核心优势在于环境适应性和动态纠错能力。
2. Plan-and-Solve:将复杂的任务分解为清晰的步骤，然后逐一执行，特别适合处理逻辑路径确定、内部推理密集的任务。比如数学应用题、代码生成任务。
3. Reflection 通过引入“执行-反思-优化”的迭代循环，将效率较低的初始代码方案，优化为高性能版本，适用于对结果的准确性和可靠性有极高要求的场景。
